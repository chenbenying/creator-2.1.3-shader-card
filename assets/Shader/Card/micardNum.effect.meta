{
  "ver": "1.0.15",
  "uuid": "16724a7b-0efd-4194-bcc4-52d63b207ef6",
  "compiledShaders": [
    {
      "vert": "\n#define _IS_VERT_SHADER 1\n\nprecision highp float;\n\nuniform mat4 cc_matViewProj;\nattribute vec3 a_position;\nattribute lowp vec4 a_color;\nattribute mediump vec2 a_uv0;\nvarying mediump vec2 v_uv0;\n\nvarying lowp vec4 v_color;\n\nuniform float sprWidth;\nuniform float sprHight;\nuniform highp vec3 xlist;\nuniform highp vec3 ylist;\nuniform highp vec2 disX;\nuniform highp vec2 disY;\n\nuniform float worldSprWidth;\nuniform float worldSprHeight;\nuniform highp vec3 xlistSymmetricPos;\nuniform highp vec3 ylistSymmetricPos;\nuniform highp vec2 disYSymmetricPos;\nuniform highp vec2 disXSymmetricPos;\n\nuniform highp vec2 worldPos;\n\nvarying highp float v_sprWidth;\nvarying highp float v_sprHight;\nvarying highp vec3 v_xlist;\nvarying highp vec3 v_ylist;\nvarying highp vec2 v_disX;\nvarying highp vec2 v_disY;\n\nvec2 getSymmetricPos(vec2 sp,vec2 pos1, vec2 pos2)\n{\n    float disX = pos2.x - pos1.x;\n    float disY = pos2.y - pos1.y;\n    if (disX == 0.0)\n    {\n        float x = pos1.x - sp.x;\n        return vec2(pos1.x + x,sp.y);\n    }\n    \n    float k1 = disY/disX;\n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    float y = (sp.y*k1*k1  + sp.x*k1 + k1*sp.x - k1*pos1.x*2.0 + pos1.y*2.0 - sp.y)/(1.0+k1*k1);\n    float x = (y - sp.y)/(-1.0/k1)+sp.x;\n\n    return vec2(x,y);\n}\n\nvoid main () {\n\n  v_sprWidth = sprWidth;\n  v_sprHight = sprHight;\n  v_xlist = xlist;\n  v_ylist = ylist;\n  v_disX = disX;\n  v_disY = disY;\n\n  vec2 pos1 = vec2(0.0,0.0);\n  vec2 pos2 = vec2(0.0,0.0);\n\n  if (disXSymmetricPos[0] != 0.0 || disXSymmetricPos[1] != 0.0)\n  {\n      if (disXSymmetricPos[0] == 0.0)\n      {\n          pos1 = vec2(disXSymmetricPos[1] + worldPos.x,worldPos.y);\n          pos2 = vec2(disXSymmetricPos[1] + worldPos.x,worldPos.y+worldSprHeight);\n      }\n      else\n      {\n          pos1 = vec2(disXSymmetricPos[0] + worldPos.x,worldPos.y);\n          pos2 = vec2(disXSymmetricPos[0] + worldPos.x,worldPos.y+worldSprHeight);\n      }\n  }\n  else if (disYSymmetricPos[0] != 0.0 || disYSymmetricPos[1] != 0.0)\n  {\n      if (disYSymmetricPos[0] == 0.0)\n      {\n          pos1 = vec2(worldPos.x,(worldSprHeight - disYSymmetricPos[1]) + worldPos.y);\n          pos2 = vec2(worldPos.x + worldSprWidth, (worldSprHeight - disYSymmetricPos[1]) + worldPos.y);\n      }\n      else\n      {\n          pos1 = vec2(worldPos.x, (worldSprHeight - disYSymmetricPos[0]) + worldPos.y);\n          pos2 = vec2(worldPos.x + worldSprWidth, (worldSprHeight - disYSymmetricPos[0]) + worldPos.y);\n      }\n  }\n  else if(xlistSymmetricPos.x != 0.0 || xlistSymmetricPos.y != 0.0 || xlistSymmetricPos.z != 0.0){\n      pos1 = vec2(xlistSymmetricPos.y+worldPos.x,worldSprHeight - ylistSymmetricPos.y + worldPos.y);\n      pos2 = vec2(xlistSymmetricPos.z+worldPos.x,worldSprHeight - ylistSymmetricPos.z + worldPos.y);\n  }\n\n  vec2 sp = vec2(a_position.x, a_position.y);\n  vec2 symmetricPos = getSymmetricPos(sp,pos1,pos2);\n  vec4 tmp_pos = vec4(a_position.x, a_position.y,a_position.z, 1.0);\n  tmp_pos.x = symmetricPos.x ;\n  tmp_pos.y = symmetricPos.y ;\n\n  mat4 mvp = cc_matViewProj;\n  v_uv0 = a_uv0;\n  v_color = a_color;\n\n  gl_Position = mvp * tmp_pos ;\n}\n\n\n",
      "frag": "\n#define _IS_FRAG_SHADER 1\n\nprecision highp float;\n\nuniform sampler2D texture;\nvarying mediump vec2 v_uv0;\n\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\n\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\n\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\n\nvarying lowp vec4 v_color;\n\nuniform float sprWidth;\nuniform float sprHight;\nuniform highp vec3 xlist;\nuniform highp vec3 ylist;\nuniform highp vec2 disX;\nuniform highp vec2 disY;\n\nbool isHide(float px , float py)\n{   \n    bool b = false;\n    float dx = px*sprWidth;\n    float dy = py*sprHight;\n    if (disX[0] != 0.0 || disX[1] != 0.0)\n    {\n        if (dx >= disX[0] && dx <= disX[1]){\n            return true;\n        }\n    }\n    else if (disY[0] != 0.0 || disY[1] != 0.0)\n    {\n        if (dy >= disY[0] && dy <= disY[1]){\n            return true;\n        }\n    }\n    \n    if ( ((ylist[0]>=dy) != (ylist[2]>=dy)) && (dx < (xlist[2]-xlist[0]) * (dy-ylist[0]) / (ylist[2]-ylist[0]) + xlist[0]) )\n    {\n       b = !b;\n    }\n    if ( ((ylist[1]>=dy) != (ylist[0]>=dy)) && (dx < (xlist[0]-xlist[1]) * (dy-ylist[1]) / (ylist[0]-ylist[1]) + xlist[1]) )\n    {\n       b = !b;\n    }\n    if ( ((ylist[2]>=dy) != (ylist[1]>=dy)) && (dx < (xlist[1]-xlist[2]) * (dy-ylist[2]) / (ylist[1]-ylist[2]) + xlist[2]) )\n    {\n       b = !b;\n    }\n\n    return b;\n}\n\nvoid main () {\n  vec4 color = texture2D(texture, v_uv0);\n\n  bool hide = isHide(v_uv0.x,v_uv0.y);\n  if (!hide)\n  {\n      color.a = 0.0;\n  }\n\n  gl_FragColor = v_color*color;\n}\n\n\n"
    }
  ],
  "subMetas": {}
}